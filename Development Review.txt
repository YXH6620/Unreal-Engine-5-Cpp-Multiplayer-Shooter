Version 1.0：
①steam联网插件导入；UE初学者包美术资产导入，动作重定向；

Version 1.1：
①创建角色类，绑定输入；

*******************************************************************************************************

Version 1.2：
①创建角色动画蓝图，建立角色动画状态机；
②继承UAnimInstance，重写NativeInitializeAnimation(初始化)和NativeUpdateAnimation(每帧)
③设定动画状态，并在动画蓝图中设定状态转移条件

*******************************************************************************************************

Version 1.3：
①Non-Seamless Travel 切换地图：
	（1）客户端断开或重连
	（2）第一次加载地图
	（3）第一次连接服务器
	（4）结束多人游戏并开启新游戏
②Seamless Traver
	（1）更加丝滑切换~避免了重连的问题
	（2）在GameMode中实现，bUse'SeamlessTravel=true。同时需要一个Transition map
③多人游戏下的切换：
	（1）UWorld::ServerTravel，旨在服务器上运行，在服务端切换地图，并且所有客户端都要跟随切换
	（2）服务器会调用APlayerController::ClientTravel
④实现：
	（1）重写PostLogin
	（2）切换地图，设置为监听服务器：
	        bUseSeamlessTravel = true;
	        World->ServerTravel(FString("/Game/Maps/BlasterMap?listen")); 
	（3）Project Settings中设置Transition map
	（4）新建GameMode的Blueprint，设置好我们的Character蓝图

*******************************************************************************************************

Version 1.4：
①网络角色权限，可参考本人博客：https://blog.csdn.net/Jason6620/article/details/129677315?spm=1001.2014.3001.5501
②创建OverheadWidget，用于显示角色权限信息
	（1）Widget中设置的文本信息需要与C++中同名，同通过SetText等进行设置
③FString::Printf(TEXT("%s"),*Role);

*******************************************************************************************************

Version 1.5：
①创建枪支类Weapon，设置StaticmeshComponent，利用已有美术资产

*******************************************************************************************************

Version 1.6：
①创建Pickup Widget，并作为Weapon的组合Class附着
②为Weapon设置了一个碰撞体，触发逻辑显示Pickup Widget

*******************************************************************************************************

Version 1.7：
①设置Client与Server的Pickup Widget显示逻辑，实现方法是DOREPLIFETIME_CONDITION，且条件是COND_OwnerOnly，即只有拥有者才显示而不是所有玩家
②设置碰撞体的pickup显示与消失的逻辑
③判断是否被控制 IsLocallyControlled()，因为只有被控制的玩家才能看到pickup

*******************************************************************************************************

Version 1.8：
①创建战斗组件，负责装备武器；将其组合至Character类；并且设置战斗组件必须为可复制（Replicated）
②设置装备动作输入绑定；
③设置Combat Component与Character、Weapon的组合关系
④设置手部骨骼Socket，利用HandSocket->AttachActor附着武器，设置Weapon的Owner，设置Pickup不显示

*******************************************************************************************************

Version 1.9：
①如果在Server摁键，则直接装备武器；
②如果在Client摁键，则需要调用RPC，在Server端执行；
③对武器状态变量EWeaponType进行属性同步（回调）：
	（1）属性注册：DOREPLIFETIME(AWeapon, WeaponState);
	（2）当装备武器就不需要再显示Pickup
	（3）回调：OnRep_WeaponState()

*******************************************************************************************************

Version 1.10：
①设置持枪的动画状态为Replicated，属性同步
②动画蓝图设置Blend pose by bool

*******************************************************************************************************

Version 1.11：
①设置蹲伏状态，动作输入绑定；
②动画状态复制

*******************************************************************************************************

Version 1.12：
①设置瞄准动作，动作输入绑定
②动画状态复制，若在Server直接瞄准，若在Client则调用RPC

*******************************************************************************************************

Version 1.13：
①角色奔跑的Blend Space

*******************************************************************************************************

Version 1.14：
①计算鼠标控制角色时的Yaw变化，并暴露给动画蓝图进行Aiming BlendSpace的控制
②角色持枪需要禁用bOrientRotationToMovement，开启bUseControllerRotationYaw；并将其进行属性同步（回调）

*******************************************************************************************************
Version 1.15：
①Idle和Jump动画状态机的实现；三个状态变量：Is Accelerating、Is In Air、Speed>=0?

*******************************************************************************************************

Version 1.16：
①设置Crouch Walking的动画混合空间，以及Crouched状态下的动画过渡

*******************************************************************************************************

Version 1.17：
①行走、蹲伏、Idle下的Aiming动画状态机实现
②Aim Offet前的九个方向动画的配置：Additive Settings->Additive Anim Type:Mesh Spcae->Base Pose Type:Selected animation frame->Zero Pose
③设置AimOffset，有两个，分别是持枪和瞄准状态下的。
④应用AimOffset，利用Layered blend per bone，设置混合骨骼为腰部骨骼spine_01，上下半身的混合；并将Yaw和Pitch暴露给动画蓝图进行混合。

*******************************************************************************************************

Version 1.18：
①网络序会对角度进行变换压缩，导致Server和Client同步的过程中出现数据不一致的情况，在Rotator.h中的CompressAxisToShort，因此需要在Client端接收到数据时进行处理
②为每一种枪支这是Left'HandSocket，并进行FBRAK IK处理
③原地旋转(Turning InPlace)：当Yaw大于90° 或 小于-90°，进行旋转，伴随着角色脚步的移动。动画状态机中判断的条件为ETurningInPlace，C++中设置 的。

*******************************************************************************************************

Version 1.19：
①网络更新频率：BP_BlasterCharacter下的Net Update Frequency，即Server Tick Rate
②角色旋转速度
③Jump打断Crouch

*******************************************************************************************************

Version 1.20：
①通过AnimNotify（动画通知）实现脚步、跳跃等声音

*******************************************************************************************************

Version 1.21：
①子弹类 VS Hitscan：即真实的子弹Actor vs 射线检测的射击。
②创建Projectile Weapon
③创建Projectile：添加碰撞体，设置碰撞预设

*******************************************************************************************************

Version 1.22：
①开火（Fire）动作绑定，
②建立Fire动画蒙太奇。设置Section Name，新建插槽WeaponSlot，Clear，暴露给蓝图进行设置。
	//以下代码值得记忆
	UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();
	if (AnimInstance && FireWeaponMontage)
	{
		AnimInstance->Montage_Play(FireWeaponMontage);
		FName SectionName;
		SectionName = bAiming ? FName("RifleAim") : FName("RifleHip");
		AnimInstance->Montage_JumpToSection(SectionName);
	}
③利用已经包含枪口火焰离子效果以及声音的 开火动画
④开火粒子效果和声音需要网络同步，逻辑顺序为：开火摁键RPC->Server->Server广播RPC

*******************************************************************************************************

Version 1.23：
①HitScan的射线发射起点：屏幕中心
②核心函数：UGameplayStatics::DeprojectScreenToWorld 进行反投影，

*******************************************************************************************************

Version 1.24：
①生成子弹：SpawnActor，在MuzzleFlashSocket.
②另：TSubClassof作用是什么？

*******************************************************************************************************

Version 1.25：
①利用UE框架已有的ProjectileMovementComponent为子弹添加运动属性，比如速度。
②为子弹添加轨迹粒子效果（Tracer）
③为子弹添加网络复制标志，bReplicates

*******************************************************************************************************

Version 1.26：
①使用FVector_NetQuantize进行了数据传输优化

*******************************************************************************************************

Version 1.27：
①子弹的碰撞逻辑：OnHit
②销毁子弹：Destroyed()
③子弹碰撞时产生粒子效果和声音：Destroyed()里实现
④子弹的网络属性复制：CollisionBox->OnComponenthit绑定的广播委托
⑤创建弹壳类，

*******************************************************************************************************

Version 1.28：
①为弹壳设置：
	AddImpluse 脉冲力
	SetSimulatePhysics 物理
	SetEnableGravity 重力
	SetNotifyRigidBodyCollosion 刚体
	OnHit：与子弹类似，播放声音等，销毁

*******************************************************************************************************

Version 1.29：
①创建BlasterPlayerController
②创建BlasterHUD；重载DrawHUD
③创建Weapon的十字准星纹理，上下左右中，设置纹理压缩设置为UI
④将PC和HUD的蓝图设置给GameMode

*******************************************************************************************************

Version 1.30：
①动态准星，与速度有关；通过 FMath::GetMappedRangeValueClamped(WalkSpeedRange, VelocityMultiplierRange, Velocity.Size());

*******************************************************************************************************

Version 1.31：
①通过摄像机组件设置瞄准时的视野大小焦距，过程间插值

*******************************************************************************************************

Version 1.32：
①创建接口，Character继承这个接口
②射线检测，检测物体为Character时判断是否继承接口，若是则改变准星颜色。
		if (TraceHitResult.GetActor() && TraceHitResult.GetActor()->Implements<UInteractWithCrosshairsInterface>())
		{
			HUDPackage.CrosshairsColor = FLinearColor::Red;
		}
		else
		{
			HUDPackage.CrosshairsColor = FLinearColor::White;
		}
③射线不能对自己生效，采取准星前一点点的地方进行判定
④解决摄像机离自己过近时遮挡视角，距离过近隐藏Mesh和枪支。

*******************************************************************************************************

Version 1.33：
①添加角色被击中的动画，并通过广播下发给所有客户端

*******************************************************************************************************

Version 1.34：
①自动开火，SetTimer，设置开火延迟delay
void UCombatComponent::Fire()
{
	if (bCanFire && EquippedWeapon)
	{
		bCanFire = false;
		ServerFire(HitTarget);
		if (EquippedWeapon)
		{
			CrosshairShootingFactor = .75f;
		}
		StartFireTimer();
	}
}

*******************************************************************************************************

Version 1.35：
①Gameplay 框架：具体可参考本人博客：https://blog.csdn.net/Jason6620/article/details/129676204?spm=1001.2014.3001.5501
	GameMode：保存Pawn、PlayerController、HUD，游戏规则。匹配状态
	GameState：游戏状态（最高分玩家、领先队伍、队伍得分、玩家的各种状态）
	PlayerState：得分、死亡数
	PlayerController：访问HUD、更新信息、HUD、分数等
②血量Health：
	（1）网络复制Health会有延迟，所以把Health放在Character身上，有更快的速度
	（2）添加血量HUD，并在Graph中设置C++为父类
void ABlasterHUD::AddCharacterOverlay()
{
	APlayerController* PlayerController = GetOwningPlayerController();
	if (PlayerController && CharacterOverlayClass)
	{
		CharacterOverlay = CreateWidget<UCharacterOverlay>(PlayerController, CharacterOverlayClass);
		CharacterOverlay->AddToViewport();
	}
}


*******************************************************************************************************

Version 1.36：
①更新血量HUD：通过PlayerController->GetHUD()。
②SetHUDHealth：算血量百分比
		BlasterHUD->CharacterOverlay->HealthBar->SetPercent(HealthPercent);
		FString HealthText = FString::Printf(TEXT("%d/%d"), FMath::CeilToInt(Health), FMath::CeilToInt(MaxHealth));
		BlasterHUD->CharacterOverlay->HealthText->SetText(FText::FromString(HealthText));
③在Character中，获取Controller来SetHUDHealth：
	BlasterPlayerController = Cast<ABlasterPlayerController>(Controller);
	if (BlasterPlayerController)
	{
		BlasterPlayerController->SetHUDHealth(Health, MaxHealth);
	}

*******************************************************************************************************

Version 1.37：
①伤害Damage：
	（1）为Projectile类的成员变量
	（2）UGameplayStatics::ApplyDamage(OtherActor, Damage, OwnerController, this, UDamageType::StaticClass());通过Controller处理damage
②接受伤害：
	（1）Character->ReceiveDamage()，处理HUD更新、播放被击动画
	（2）源码自带：OnTakeAnyDamage。是个广播委托，处理伤害
	
*******************************************************************************************************

Version 1.38：
①创建BlasterGamemode：处理角色死亡时的逻辑，并且更改原蓝图GameMode中的父类
	virtual void PlayerEliminated(class ABlasterCharacter* ElimmedCharacter, class ABlasterPlayerController* VictimController, ABlasterPlayerController* AttackerController);
②MultiCast_Elim Animation、广播
③ElimTimer：
	GetWorldTimerManager().SetTimer(
		ElimTimer,
		this,
		&ABlasterCharacter::ElimTimerFinished,
		ElimDelay
	);
④Gamemode中设置重生逻辑：
	（1）Character需要Reset、Destroy
	（2）轮询重生点
	（3）Spawn Collision Handling Method：Try to Adjust Location, Bug Always Spawn

⑤添加死亡时角色溶解材质效果

*******************************************************************************************************

Version 1.39：
①人物死亡效果，材质曲线

*******************************************************************************************************

Version 1.40：
①角色死亡：
	（1）禁用移动、禁用输入
	（2）禁用碰撞
	（3）掉落武器：Weapon State（Dropped）、重力 物理、DetachfromComponent()、SetOwner(nullptr)
②死亡时播放粒子（机器人）和声音

*******************************************************************************************************

Version 1.41：
①OnPossess：人物重生后重设HUD

*******************************************************************************************************

Version 1.42：
①创建BlasterPlayerState：
	（1）内置Score，重写OnRep_Score
	（2）通过Controller改写HUD中的Score
	（3）PlayerEliminated中判断攻击者和受害者是否为同一个，若不是则攻击者加分AddToScore
	（4）创建BP_BlasterPlayerState，设置GameMode
	（5）PlayerState在第一帧是无效的。nulllptr，因此需要轮询做初始化。
②加分与死亡得分计数逻辑
	（1）SetScore 内置
	（2）与①逻辑类似，PlayerEliminated中判断攻击者和受害者是否为同一个，若受害者是AddToDefeats
	（3）PollInit轮询也需要更新Defeat
	（4）

*******************************************************************************************************

Version 1.43：
①子弹数Ammo 及最大容量MagCapacity：
	（1）需要同步复制
	（2）OnRep_Ammo() 更新HUD
②装备武器：
	（1）如果已有武器，则需要丢掉当前武器
	（2）装备武器是更新HUD
	（3）玩家死亡后将Ammo设置为0
	（4）掉落武器，将所属character和controller设置为nullptr
	（5）OnRep_Owner() 更新Owner

*******************************************************************************************************

Version 1.44：
①检查弹药，判断是否Fire
②弹夹弹药：
	（1）条件复制，只会复制到Owner的客户端
	（2）设置HUD，逻辑类似

*******************************************************************************************************

Version 1.45：
①换弹
	（1）动作绑定键盘映射
	（2）添加换单动画蒙太奇
	（3）根据不同武器播放不同蒙太奇	
	（4）换弹动画需要同步RPC，
②战斗状态：
	（1）ECS_Unoccpied：
	（2）需要属性同步
	（3）

*******************************************************************************************************

Version 1.46：
①修复了一个bug，在Reloading时不能fire
②换子弹
	（1）数量：Clamp(RoomInMag,0,min(RoomInMag,CarriedAmmo));，其中(RoomInMag为需要填充的子弹数，并且在剩余子弹与填充子弹中取min
	（2）SetHUDCarriedAmmo

*******************************************************************************************************

Version 1.47：
①添加换弹音效
②自动换弹

*******************************************************************************************************

Version 1.48：
①GameTimer：PlayerController设定HUD。但C&S同步未解决
	SetHUDMatchCountdown(MatchTime - GetWorld()->GetTimeSeconds())

*******************************************************************************************************

Version 1.49：
①C&S GameTimer同步：
	（1）1/2RTT：虽然不准确，但对于这个Demo来说足够了
②***待研究***

*******************************************************************************************************

Version 1.50：
①AGameModeBase：
	（1）Default Classes
	（2）Spawns Player's Pawn
	（3）Restart Players
	（4）Restart the Game
②AGameMode：public AGameModeBase
	（1）Match State（但大多数游戏都不需要匹配状态）
	（2）Handling Match States
	（3）Custom Match States
③MatchState：
	namespace MatchState
		EnteringMap			HasMatchStarted()
		WaitingToStart			HasMatchEnded()
		InProgres (Only new state here!!!!)	GetMatchState()
		WaitingPostMatch			SetMatchState()
		LeavingMap			OnMatchStateSet()
		Aborted				StartMatch()
④Delayed Start
	（1）Stay in the WaitingToStart State
		· WarmupTime
	（2）Call StartMatch()
		· Transition to the InProgress State
		· Spawn Characters

*******************************************************************************************************

Version 1.51：
①OnMatchStateSet

*******************************************************************************************************


