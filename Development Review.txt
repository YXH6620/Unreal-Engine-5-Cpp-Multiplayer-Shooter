Version 1.0：
①steam联网插件导入；UE初学者包美术资产导入，动作重定向；

Version 1.1：
①创建角色类，绑定输入；

*******************************************************************************************************

Version 1.2：
①创建角色动画蓝图，建立角色动画状态机；
②继承UAnimInstance，重写NativeInitializeAnimation(初始化)和NativeUpdateAnimation(每帧)
③设定动画状态，并在动画蓝图中设定状态转移条件

*******************************************************************************************************

Version 1.3：
①Non-Seamless Travel 切换地图：
	（1）客户端断开或重连
	（2）第一次加载地图
	（3）第一次连接服务器
	（4）结束多人游戏并开启新游戏
②Seamless Traver
	（1）更加丝滑切换~避免了重连的问题
	（2）在GameMode中实现，bUse'SeamlessTravel=true。同时需要一个Transition map
③多人游戏下的切换：
	（1）UWorld::ServerTravel，旨在服务器上运行，在服务端切换地图，并且所有客户端都要跟随切换
	（2）服务器会调用APlayerController::ClientTravel
④实现：
	（1）重写PostLogin
	（2）切换地图，设置为监听服务器：
	        bUseSeamlessTravel = true;
	        World->ServerTravel(FString("/Game/Maps/BlasterMap?listen")); 
	（3）Project Settings中设置Transition map
	（4）新建GameMode的Blueprint，设置好我们的Character蓝图

*******************************************************************************************************

Version 1.4：
①网络角色权限，可参考本人博客：https://blog.csdn.net/Jason6620/article/details/129677315?spm=1001.2014.3001.5501
②创建OverheadWidget，用于显示角色权限信息
	（1）Widget中设置的文本信息需要与C++中同名，同通过SetText等进行设置
③FString::Printf(TEXT("%s"),*Role);

*******************************************************************************************************

Version 1.5：
①创建枪支类Weapon，设置StaticmeshComponent，利用已有美术资产

*******************************************************************************************************

Version 1.6：
①创建Pickup Widget，并作为Weapon的组合Class附着
②为Weapon设置了一个碰撞体，触发逻辑显示Pickup Widget

*******************************************************************************************************

Version 1.7：
①设置Client与Server的Pickup Widget显示逻辑，实现方法是DOREPLIFETIME_CONDITION，且条件是COND_OwnerOnly，即只有拥有者才显示而不是所有玩家
②设置碰撞体的pickup显示与消失的逻辑
③判断是否被控制 IsLocallyControlled()，因为只有被控制的玩家才能看到pickup

*******************************************************************************************************

Version 1.8：
①创建战斗组件，负责装备武器；将其组合至Character类；并且设置战斗组件必须为可复制（Replicated）
②设置装备动作输入绑定；
③设置Combat Component与Character、Weapon的组合关系
④设置手部骨骼Socket，利用HandSocket->AttachActor附着武器，设置Weapon的Owner，设置Pickup不显示

*******************************************************************************************************

Version 1.9：
①如果在Server摁键，则直接装备武器；
②如果在Client摁键，则需要调用RPC，在Server端执行；
③对武器状态变量EWeaponType进行属性同步（回调）：
	（1）属性注册：DOREPLIFETIME(AWeapon, WeaponState);
	（2）当装备武器就不需要再显示Pickup
	（3）回调：OnRep_WeaponState()

*******************************************************************************************************

Version 1.10：
①设置持枪的动画状态为Replicated，属性同步
②动画蓝图设置Blend pose by bool

*******************************************************************************************************

Version 1.11：
①设置蹲伏状态，动作输入绑定；
②动画状态复制

*******************************************************************************************************

Version 1.12：
①设置瞄准动作，动作输入绑定
②动画状态复制，若在Server直接瞄准，若在Client则调用RPC

*******************************************************************************************************

Version 1.13：
①角色奔跑的Blend Space

*******************************************************************************************************

Version 1.14：
①计算鼠标控制角色时的Yaw变化，并暴露给动画蓝图进行Aiming BlendSpace的控制
②角色持枪需要禁用bOrientRotationToMovement，开启bUseControllerRotationYaw；并将其进行属性同步（回调）

*******************************************************************************************************
Version 1.15：
①Idle和Jump动画状态机的实现；三个状态变量：Is Accelerating、Is In Air、Speed>=0?

*******************************************************************************************************

Version 1.16：
①设置Crouch Walking的动画混合空间，以及Crouched状态下的动画过渡

*******************************************************************************************************

Version 1.17：
①行走、蹲伏、Idle下的Aiming动画状态机实现
②Aim Offet前的九个方向动画的配置：Additive Settings->Additive Anim Type:Mesh Spcae->Base Pose Type:Selected animation frame->Zero Pose
③设置AimOffset，有两个，分别是持枪和瞄准状态下的。
④应用AimOffset，利用Layered blend per bone，设置混合骨骼为腰部骨骼spine_01，上下半身的混合；并将Yaw和Pitch暴露给动画蓝图进行混合。

*******************************************************************************************************

Version 1.18：
①网络序会对角度进行变换压缩，导致Server和Client同步的过程中出现数据不一致的情况，在Rotator.h中的CompressAxisToShort，因此需要在Client端接收到数据时进行处理
②为每一种枪支这是Left'HandSocket，并进行FBRAK IK处理
③原地旋转(Turning InPlace)：当Yaw大于90° 或 小于-90°，进行旋转，伴随着角色脚步的移动。动画状态机中判断的条件为ETurningInPlace，C++中设置 的。

*******************************************************************************************************

Version 1.19：
①网络更新频率：BP_BlasterCharacter下的Net Update Frequency，即Server Tick Rate
②角色旋转速度
③Jump打断Crouch

*******************************************************************************************************

Version 1.20：
①通过AnimNotify（动画通知）实现脚步、跳跃等声音

*******************************************************************************************************

Version 1.21：
①子弹类 VS Hitscan：即真实的子弹Actor vs 射线检测的射击。
②创建Projectile Weapon
③创建Projectile：添加碰撞体，设置碰撞预设

*******************************************************************************************************

Version 1.22：
①开火（Fire）动作绑定，
②建立Fire动画蒙太奇。设置Section Name，新建插槽WeaponSlot，Clear，暴露给蓝图进行设置。
	//以下代码值得记忆
	UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();
	if (AnimInstance && FireWeaponMontage)
	{
		AnimInstance->Montage_Play(FireWeaponMontage);
		FName SectionName;
		SectionName = bAiming ? FName("RifleAim") : FName("RifleHip");
		AnimInstance->Montage_JumpToSection(SectionName);
	}
③利用已经包含枪口火焰离子效果以及声音的 开火动画
④开火粒子效果和声音需要网络同步，逻辑顺序为：开火摁键RPC->Server->Server广播RPC

*******************************************************************************************************

Version 1.23：
①HitScan的射线发射起点：屏幕中心
②核心函数：UGameplayStatics::DeprojectScreenToWorld 进行反投影，

*******************************************************************************************************

Version 1.24：
①生成子弹：SpawnActor，在MuzzleFlashSocket.
②另：TSubClassof作用是什么？

*******************************************************************************************************

Version 1.25：
①利用UE框架已有的ProjectileMovementComponent为子弹添加运动属性，比如速度。
②为子弹添加轨迹粒子效果（Tracer）
③为子弹添加网络复制标志，bReplicates

*******************************************************************************************************

Version 1.26：
①使用FVector_NetQuantize进行了数据传输优化

*******************************************************************************************************

Version 1.27：
①子弹的碰撞逻辑：OnHit
②销毁子弹：Destroyed()
③子弹碰撞时产生粒子效果和声音：Destroyed()里实现
④子弹的网络属性复制：CollisionBox->OnComponenthit绑定的广播委托
⑤创建弹壳类，

*******************************************************************************************************

Version 1.28：
①为弹壳设置：
	AddImpluse 脉冲力
	SetSimulatePhysics 物理
	SetEnableGravity 重力
	SetNotifyRigidBodyCollosion 刚体
	OnHit：与子弹类似，播放声音等，销毁

*******************************************************************************************************

Version 1.29：
①创建BlasterPlayerController
②创建BlasterHUD；重载DrawHUD
③创建Weapon的十字准星纹理，上下左右中，设置纹理压缩设置为UI
④将PC和HUD的蓝图设置给GameMode

*******************************************************************************************************

Version 1.30：
①动态准星，与速度有关；通过 FMath::GetMappedRangeValueClamped(WalkSpeedRange, VelocityMultiplierRange, Velocity.Size());

*******************************************************************************************************

Version 1.31：
①通过摄像机组件设置瞄准时的视野大小焦距，过程间插值

*******************************************************************************************************

Version 1.32：
①创建接口，Character继承这个接口
②射线检测，检测物体为Character时判断是否继承接口，若是则改变准星颜色。
		if (TraceHitResult.GetActor() && TraceHitResult.GetActor()->Implements<UInteractWithCrosshairsInterface>())
		{
			HUDPackage.CrosshairsColor = FLinearColor::Red;
		}
		else
		{
			HUDPackage.CrosshairsColor = FLinearColor::White;
		}
③射线不能对自己生效，采取准星前一点点的地方进行判定
④解决摄像机离自己过近时遮挡视角，距离过近隐藏Mesh和枪支。

*******************************************************************************************************

Version 1.33：
①添加角色被击中的动画，并通过广播下发给所有客户端

*******************************************************************************************************

Version 1.34：
①自动开火，SetTimer，设置开火延迟delay
void UCombatComponent::Fire()
{
	if (bCanFire && EquippedWeapon)
	{
		bCanFire = false;
		ServerFire(HitTarget);
		if (EquippedWeapon)
		{
			CrosshairShootingFactor = .75f;
		}
		StartFireTimer();
	}
}

*******************************************************************************************************



